{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Python client for the Factorial API. Documentation : https://dribia.github.io/drifactorial Source Code : https://github.com/dribia/drifactorial Factorial is a software dedicated to manage everything related to HR. Drifactorial provides a tiny Python interface to the official API. Key features \ud83d\udd17 Authorize programatic access to your application. Obtain and refresh access tokens . Implements generic GET and POST methods. Parses responses to Pydantic models . Easily implement additional methods . Example \ud83d\udd17 The simplest example. from drifactorial import Factorial from datetime import datetime factorial = Factorial ( access_token = \"abc\" ) # get list of employees employees = factorial . get_employees () # get list of company holidays holidays = factorial . get_holidays () # get list of leaves leaves = factorial . get_leaves () # get list of days off of an employee daysoff = factorial . get_daysoff ( employee_id = 123 ) # get list of all shifts in October 2021 shifts = factorial . get_shifts ( year = 2021 , month = 10 ) # get single employee single_employee = factorial . get_single_employee ( employee_id = 123 ) # get my account account = factorial . get_account () # clock in shift clock_in = datetime ( 2021 , 10 , 1 , 9 , 0 ) new_shift = factorial . clock_in ( now = clock_in , employee_id = 123 ) # clock out shift clock_out = datetime ( 2021 , 10 , 1 , 13 , 0 ) updated_shift = factorial . clock_out ( now = clock_in , employee_id = 123 )","title":"drifactorial"},{"location":"#key-features","text":"Authorize programatic access to your application. Obtain and refresh access tokens . Implements generic GET and POST methods. Parses responses to Pydantic models . Easily implement additional methods .","title":"Key features"},{"location":"#example","text":"The simplest example. from drifactorial import Factorial from datetime import datetime factorial = Factorial ( access_token = \"abc\" ) # get list of employees employees = factorial . get_employees () # get list of company holidays holidays = factorial . get_holidays () # get list of leaves leaves = factorial . get_leaves () # get list of days off of an employee daysoff = factorial . get_daysoff ( employee_id = 123 ) # get list of all shifts in October 2021 shifts = factorial . get_shifts ( year = 2021 , month = 10 ) # get single employee single_employee = factorial . get_single_employee ( employee_id = 123 ) # get my account account = factorial . get_account () # clock in shift clock_in = datetime ( 2021 , 10 , 1 , 9 , 0 ) new_shift = factorial . clock_in ( now = clock_in , employee_id = 123 ) # clock out shift clock_out = datetime ( 2021 , 10 , 1 , 13 , 0 ) updated_shift = factorial . clock_out ( now = clock_in , employee_id = 123 )","title":"Example"},{"location":"contribute/","text":"Contribute \ud83d\udd17 Contributions to Dribia libraries are always welcome! Mantainers \ud83d\udd17 drifactorial is maintained by: Xavier Hoffmann - xrhoffmann@gmail.com Issues \ud83d\udd17 Questions, feature requests and bug reports are all welcome as discussions or issues . Please note which version of the library are you using whenever reporting a bug. python -c \"import drifactorial; print(drifactorial.__version__)\" It would be very useful too to know which OS and Python version you are running drifactorial from. Contribute \ud83d\udd17 In order to contribute, the first step is to clone the code from the repository : git clone https://github.com/dribia/drifactorial.git Then, you can step into the project's root and, assuming that you have both Poetry and pre-commit installed, run: poetry install && pre-commit install Now you should be ready to start coding and prepare your pull request . You can run linting and tests locally with: sh scripts/lint.sh sh scripts/test.sh Happy coding!","title":"Contribute"},{"location":"contribute/#contribute","text":"Contributions to Dribia libraries are always welcome!","title":"Contribute"},{"location":"contribute/#mantainers","text":"drifactorial is maintained by: Xavier Hoffmann - xrhoffmann@gmail.com","title":"Mantainers"},{"location":"contribute/#issues","text":"Questions, feature requests and bug reports are all welcome as discussions or issues . Please note which version of the library are you using whenever reporting a bug. python -c \"import drifactorial; print(drifactorial.__version__)\" It would be very useful too to know which OS and Python version you are running drifactorial from.","title":"Issues"},{"location":"contribute/#contribute_1","text":"In order to contribute, the first step is to clone the code from the repository : git clone https://github.com/dribia/drifactorial.git Then, you can step into the project's root and, assuming that you have both Poetry and pre-commit installed, run: poetry install && pre-commit install Now you should be ready to start coding and prepare your pull request . You can run linting and tests locally with: sh scripts/lint.sh sh scripts/test.sh Happy coding!","title":"Contribute"},{"location":"install/","text":"PIP \ud83d\udd17 Installation is as simple as: pip install drifactorial Drifactorial heavily will install the dependency: Pydantic is a data validation framework using Python type annotations.","title":"Install"},{"location":"install/#pip","text":"Installation is as simple as: pip install drifactorial Drifactorial heavily will install the dependency: Pydantic is a data validation framework using Python type annotations.","title":"PIP"},{"location":"usage/authorization/","text":"Create a new application \ud83d\udd17 In order to use the Factorial API you need a custom Oauth application. You can manage your applications at the corresponding dashboard . You must log in as admin to access this dashboard (in principle). Tip If you are creating a new application and are unsure about the settings, use the suggested Redirect URI and check the Confidential box. Success Once you have created your application, keep the client_id , client_secret and redirect_uri nearby. Authorize your user for using the application \ud83d\udd17 Before a user can use the application we must grant them authorization. Instantiate the Factorial class with a dummy access_token (we don't have one). dummy_factorial = Factorial(access_token=\"abc\") Call the authorize method with the client_id and redirect_uri that your stored previously. The optional scope argument can be read , write or read+write (these values are self-explicatory), and defaults to the latter. dummy_factorial.authorize( client_id=client_id, redirect_uri=redirect_uri, ) The console will show a link. The user must copy this link into a browser. After logging in with their Factorial user, the browser will show an authorization_key . Success Keep this authorization_key nearby. Obtain your first access token \ud83d\udd17 Finally we can obtain our first access token. Call the obtain_access_token method with the client_id , client_secret and redirect_uri from the first step and the authorization_key from the second step. token = dummy_factorial.obtain_access_token( client_id=client_id, client_secret=client_secret, redirect_uri=redirect_uri, authorization_key=authorization_key, ) This will return a Token object. Warning It is super important to store this token data in a secure location! Besides the obvious token.access_token that we will use to access the API, the attribute token.refresh_token will be needed when the token expires. Finally we instantiate the Factorial class with a valid access_token . factorial = Factorial(access_token=token.access_token) Info All tokens have a lifetime of 7 days, afterwards they expire. Tip If you call the obtain_access_token again, with the same arguments and before the token expires, you will obtain exactly the same token (with the same expiry date). Tip You can authorize the same user with different scopes ( read , write or read+write ), each will need its own access token. Refresh your access token \ud83d\udd17 After you token expires you must refresh it. Call the refresh_access_token with the client_id and client_secret from the first step and the refresh_token that you stored from the previous step. token = factorial.refresh_access_token( client_id=client_id, client_secret=client_secret, refresh_token=token.refresh_token ) This will return a Token object. Warning Guard this new token data in a secure location! It provides a new token.access_token and also a new token.refresh_token for future refreshments.","title":"Authorization"},{"location":"usage/authorization/#create-a-new-application","text":"In order to use the Factorial API you need a custom Oauth application. You can manage your applications at the corresponding dashboard . You must log in as admin to access this dashboard (in principle). Tip If you are creating a new application and are unsure about the settings, use the suggested Redirect URI and check the Confidential box. Success Once you have created your application, keep the client_id , client_secret and redirect_uri nearby.","title":"Create a new application"},{"location":"usage/authorization/#authorize-your-user-for-using-the-application","text":"Before a user can use the application we must grant them authorization. Instantiate the Factorial class with a dummy access_token (we don't have one). dummy_factorial = Factorial(access_token=\"abc\") Call the authorize method with the client_id and redirect_uri that your stored previously. The optional scope argument can be read , write or read+write (these values are self-explicatory), and defaults to the latter. dummy_factorial.authorize( client_id=client_id, redirect_uri=redirect_uri, ) The console will show a link. The user must copy this link into a browser. After logging in with their Factorial user, the browser will show an authorization_key . Success Keep this authorization_key nearby.","title":"Authorize your user for using the application"},{"location":"usage/authorization/#obtain-your-first-access-token","text":"Finally we can obtain our first access token. Call the obtain_access_token method with the client_id , client_secret and redirect_uri from the first step and the authorization_key from the second step. token = dummy_factorial.obtain_access_token( client_id=client_id, client_secret=client_secret, redirect_uri=redirect_uri, authorization_key=authorization_key, ) This will return a Token object. Warning It is super important to store this token data in a secure location! Besides the obvious token.access_token that we will use to access the API, the attribute token.refresh_token will be needed when the token expires. Finally we instantiate the Factorial class with a valid access_token . factorial = Factorial(access_token=token.access_token) Info All tokens have a lifetime of 7 days, afterwards they expire. Tip If you call the obtain_access_token again, with the same arguments and before the token expires, you will obtain exactly the same token (with the same expiry date). Tip You can authorize the same user with different scopes ( read , write or read+write ), each will need its own access token.","title":"Obtain your first access token"},{"location":"usage/authorization/#refresh-your-access-token","text":"After you token expires you must refresh it. Call the refresh_access_token with the client_id and client_secret from the first step and the refresh_token that you stored from the previous step. token = factorial.refresh_access_token( client_id=client_id, client_secret=client_secret, refresh_token=token.refresh_token ) This will return a Token object. Warning Guard this new token data in a secure location! It provides a new token.access_token and also a new token.refresh_token for future refreshments.","title":"Refresh your access token"},{"location":"usage/methods/","text":"Info Methods regarding authorization and access are described in the Authorization page. Tip Most methods return custom pydantic objects. See schemas.py for details. get_account \ud83d\udd17 Obtain information about the user's account. Returns an Account object. get_employees \ud83d\udd17 Obtain information about all employees: previously terminated, currently active and future hirings, from all locations. Returns a list of Employee objects. get_single_employee \ud83d\udd17 Obtain information about a single employee. Returns a single Employee object. get_shifts \ud83d\udd17 Obtain information about all shifts: from all employees, from all times. Results can be filtered for a specific month with the arguments year and month . Both arguments must be provided in order to filter the results. Indicating only the year has no filtering effect. Results can also be filtered for a specific employee with the argument employee_id . Returns a list of Shift objects. clock_in \ud83d\udd17 Create a new shift for a given employee_id with a given clock-in time now . Returns a single Shift object. Warning You can't create a new shift if there is still an open shift that hasn't been clocked-out (see Shift restrictions for details). clock_out \ud83d\udd17 Update an open shift for a given employee_id with a given clock-out time now . Returns a single Shift object. Warning You can't clock-out a shift that hasn't been clocked-out (see Shift restrictions for details). get_leaves \ud83d\udd17 Obtain information about all leaves: from all employees, from all times. Results can be filtered starting from a specific start date and/or ending at a specific end date (both dates are included in the filter, see note). Results can also be filtered for a specific employee with the argument employee_id . Returns a list of Leave objects. Tip Leaves that correspond to full days ( half_day=None ) have a start_on date and a finish_on date. Leaves that correspond to half days can be either mornings ( half_day=\"beggining_of_day\" , note the typo!) or afternoons ( half_day=\"end_of_day\" ). Warning When filtering with start and/or end dates, the filter returns all leaves that have at least one day in the interval. For example, a leave that starts on 01/12/2021 and finishes on 05/12/2021 will be included if we filter with start=03/12/2021 . get_holidays \ud83d\udd17 Obtain information about all company holidays: from all locations, from all times. Results can be filtered starting from a specific start date and/or ending at a specific end date (both dates are included in the filter). Returns a list of Holiday objects. Tip All holidays correspond to a single date . Holidays that correspond to half days can be either mornings ( half_day=\"beggining_of_day\" , note the typo!) or afternoons ( half_day=\"end_of_day\" ). get_daysoff \ud83d\udd17 Obtain information about all days off (holidays and leaves) from a given employee_id . Only leaves with approved=True are included. Results can be filtered starting from a specific start date and/or ending at a specific end date (both dates are included in the filter). Results can also be filtered in order to include weekend days with include_weekends=True . Returns a tuple of 3 objects: A list of date objects corresponding to full days off. A list of date objects corresponding to mornings off. A list of date objects corresponding to afternoons off.","title":"Methods"},{"location":"usage/methods/#get_account","text":"Obtain information about the user's account. Returns an Account object.","title":"get_account"},{"location":"usage/methods/#get_employees","text":"Obtain information about all employees: previously terminated, currently active and future hirings, from all locations. Returns a list of Employee objects.","title":"get_employees"},{"location":"usage/methods/#get_single_employee","text":"Obtain information about a single employee. Returns a single Employee object.","title":"get_single_employee"},{"location":"usage/methods/#get_shifts","text":"Obtain information about all shifts: from all employees, from all times. Results can be filtered for a specific month with the arguments year and month . Both arguments must be provided in order to filter the results. Indicating only the year has no filtering effect. Results can also be filtered for a specific employee with the argument employee_id . Returns a list of Shift objects.","title":"get_shifts"},{"location":"usage/methods/#clock_in","text":"Create a new shift for a given employee_id with a given clock-in time now . Returns a single Shift object. Warning You can't create a new shift if there is still an open shift that hasn't been clocked-out (see Shift restrictions for details).","title":"clock_in"},{"location":"usage/methods/#clock_out","text":"Update an open shift for a given employee_id with a given clock-out time now . Returns a single Shift object. Warning You can't clock-out a shift that hasn't been clocked-out (see Shift restrictions for details).","title":"clock_out"},{"location":"usage/methods/#get_leaves","text":"Obtain information about all leaves: from all employees, from all times. Results can be filtered starting from a specific start date and/or ending at a specific end date (both dates are included in the filter, see note). Results can also be filtered for a specific employee with the argument employee_id . Returns a list of Leave objects. Tip Leaves that correspond to full days ( half_day=None ) have a start_on date and a finish_on date. Leaves that correspond to half days can be either mornings ( half_day=\"beggining_of_day\" , note the typo!) or afternoons ( half_day=\"end_of_day\" ). Warning When filtering with start and/or end dates, the filter returns all leaves that have at least one day in the interval. For example, a leave that starts on 01/12/2021 and finishes on 05/12/2021 will be included if we filter with start=03/12/2021 .","title":"get_leaves"},{"location":"usage/methods/#get_holidays","text":"Obtain information about all company holidays: from all locations, from all times. Results can be filtered starting from a specific start date and/or ending at a specific end date (both dates are included in the filter). Returns a list of Holiday objects. Tip All holidays correspond to a single date . Holidays that correspond to half days can be either mornings ( half_day=\"beggining_of_day\" , note the typo!) or afternoons ( half_day=\"end_of_day\" ).","title":"get_holidays"},{"location":"usage/methods/#get_daysoff","text":"Obtain information about all days off (holidays and leaves) from a given employee_id . Only leaves with approved=True are included. Results can be filtered starting from a specific start date and/or ending at a specific end date (both dates are included in the filter). Results can also be filtered in order to include weekend days with include_weekends=True . Returns a tuple of 3 objects: A list of date objects corresponding to full days off. A list of date objects corresponding to mornings off. A list of date objects corresponding to afternoons off.","title":"get_daysoff"},{"location":"usage/shift_restrictions/","text":"The Factorial API is supposed to restrict creating new shifts if the previous one is still open or updating shifts that don't exist. However, it is buggy and presents some unexpected behavior. Danger The API may be slow in responding when clocking in and out. It is recommended to add a generous time-out. Clocking in \ud83d\udd17 Expected behavior You can't create a new shift if the previous shift still open. Imagine you clock-in a shift on 01/12/2021 at 09:00 . In principle (the API has shown some bugs...) you must first clock-out this shift, say at 13:00 . Afterwards you will be able to clock-in new shifts. Now consider the scenario where we follow the previous step clocking in a shift on 30/11/2021 at 09:00 . We would expect that we must first close this shift before being able to create a new one. However, given that there exists a later closed shift we are able to clock-in a new shift (for example, on 02/12/2021 at 09:00 ) even if the shift from 30/11/2021 is still open. Clocking out \ud83d\udd17 Expected behavior You can't clock-out a shift that hasn't been clocked-in. This is true, however care should be taken if clock-out on a different date. Image you clock-in on 01/12/2021 at 09:00 . Afterwards you clock-out on 02/12/2021 at 19:00 . This will cause the shift of 01/12/2021 to be clocked-out at 23:59 and it will create a new shift on 02/12/2021 with clock-in time 00:00 and clock-out time 19:00 . Beware that the clock_out method will return a single Shift object, corresponding to the date that you have provided. Also, you can only clock-out the most recent open shift . In the buggy example that we discussed in the Clocking in section, we will never be able to programmatically clock-out the shift from 30/11/2021 that has remained open. The user will have to update it manually using the web interface.","title":"Shift restrictions"},{"location":"usage/shift_restrictions/#clocking-in","text":"Expected behavior You can't create a new shift if the previous shift still open. Imagine you clock-in a shift on 01/12/2021 at 09:00 . In principle (the API has shown some bugs...) you must first clock-out this shift, say at 13:00 . Afterwards you will be able to clock-in new shifts. Now consider the scenario where we follow the previous step clocking in a shift on 30/11/2021 at 09:00 . We would expect that we must first close this shift before being able to create a new one. However, given that there exists a later closed shift we are able to clock-in a new shift (for example, on 02/12/2021 at 09:00 ) even if the shift from 30/11/2021 is still open.","title":"Clocking in"},{"location":"usage/shift_restrictions/#clocking-out","text":"Expected behavior You can't clock-out a shift that hasn't been clocked-in. This is true, however care should be taken if clock-out on a different date. Image you clock-in on 01/12/2021 at 09:00 . Afterwards you clock-out on 02/12/2021 at 19:00 . This will cause the shift of 01/12/2021 to be clocked-out at 23:59 and it will create a new shift on 02/12/2021 with clock-in time 00:00 and clock-out time 19:00 . Beware that the clock_out method will return a single Shift object, corresponding to the date that you have provided. Also, you can only clock-out the most recent open shift . In the buggy example that we discussed in the Clocking in section, we will never be able to programmatically clock-out the shift from 30/11/2021 that has remained open. The user will have to update it manually using the web interface.","title":"Clocking out"}]}